<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Canvas Platformer — Javascript AI Assisted Coding</title>
	<style>
		html,body{height:100%;margin:0;background:#222;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto}
		#game {display:block;margin:20px auto;border:4px solid #444;background:#111;}
		.info{width:800px;margin:8px auto;text-align:center;font-size:14px;color:#bbb}
		button{margin-left:8px}
	</style>
</head>
<body>
		<div class="info">Use ← → to move, ↑ / W / Space to jump. Gamepad supported (no touch). Reach the green flag to win. <button id="restart">Restart</button>
			<button id="prevLevel">Prev Level</button>
			<button id="nextLevel">Next Level</button>
		</div>
	<canvas id="game" width="800" height="450" aria-label="Platformer game"></canvas>

	<script>
	// Minimal single-file platformer
	const canvas = document.getElementById('game');
	const ctx = canvas.getContext('2d');
	const W = canvas.width, H = canvas.height;

	// Input
	const keys = {};
	window.addEventListener('keydown', e=>{ keys[e.code]=true; e.preventDefault(); });
	window.addEventListener('keyup', e=>{ keys[e.code]=false; });

	// Gamepad state
	let gpConnected = false;
	let gpIndex = null;
	window.addEventListener('gamepadconnected', (e)=>{ gpConnected = true; gpIndex = e.gamepad.index; console.log('Gamepad connected', e.gamepad); });
	window.addEventListener('gamepaddisconnected', (e)=>{ gpConnected = false; gpIndex = null; console.log('Gamepad disconnected'); });

	document.getElementById('restart').addEventListener('click', ()=>init());

		// World
		let player, platforms, flag, gravity = 0.6;
		let collectibles = [];
		let enemies = [];
		let particles = [];
		let score = 0, lives = 3;

		// Levels
		const levels = [
			{
				platforms: [
					{x:0,y:400,w:1200,h:50},
					{x:200,y:330,w:120,h:16},
					{x:420,y:270,w:100,h:16},
					{x:620,y:220,w:160,h:16},
					{x:920,y:330,w:100,h:16},
					{x:780,y:120,w:80,h:16}
				],
				flag: {x:1100,y:80,w:24,h:40},
				collectibles: [ {x:220,y:290},{x:440,y:230},{x:940,y:290} ],
				enemies: [ {x:500,y:250,range:[420,560],dir:1} ]
			},
			{
				platforms: [
					{x:0,y:420,w:1600,h:50},
					{x:140,y:350,w:120,h:16},
					{x:360,y:300,w:90,h:16},
					{x:520,y:240,w:160,h:16},
					{x:820,y:320,w:100,h:16},
					{x:1180,y:200,w:120,h:16}
				],
				flag: {x:1500,y:140,w:24,h:40},
				collectibles: [ {x:160,y:310},{x:540,y:200},{x:1220,y:160} ],
				enemies: [ {x:700,y:220,range:[600,900],dir:1}, {x:1300,y:170,range:[1200,1400],dir:-1} ]
			}
		];
		let currentLevel = 0;

	// Camera (world coordinates). The world is larger than the canvas horizontally.
	const world = {width:1600, height:900};
	let camera = {x:0,y:0,w:W,h:H, sx:0, sy:0}; // camera.sx/sy are smooth targets

	function init(){
			player = {x:50,y:300,w:28,h:42,vx:0,vy:0,onGround:false};
			loadLevel(currentLevel);
		player.vx = player.vy = 0;
		loop();
	}

		function loadLevel(n){
			const lvl = levels[n];
			platforms = JSON.parse(JSON.stringify(lvl.platforms));
			flag = Object.assign({}, lvl.flag);
			collectibles = lvl.collectibles.map(c=>({x:c.x,y:c.y,w:12,h:12,collected:false}));
			enemies = lvl.enemies.map(e=>({x:e.x,y:e.y,w:28,h:28,range:e.range,dir:e.dir,spd:1.2}));
			world.width = Math.max(1600, (flag.x + 300));
			score = 0;
		}

	function rectsOverlap(a,b){
		return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
	}

	function physics(dt){
		// Horizontal movement
		const accel = 0.8, maxSpeed = 5, friction = 0.75;
		// Keyboard
		if (keys['ArrowLeft'] || keys['KeyA']) { player.vx -= accel; }
		if (keys['ArrowRight'] || keys['KeyD']) { player.vx += accel; }
		// Gamepad (axes[0])
		if (gpConnected){
			const gp = navigator.getGamepads()[gpIndex];
			if (gp){
				const ax = gp.axes[0] || 0;
				if (ax < -0.2) player.vx += ax * accel * 1.5; // left
				if (ax > 0.2) player.vx += ax * accel * 1.5; // right
			}
		}
		if (!(keys['ArrowLeft']||keys['KeyA']||keys['ArrowRight']||keys['KeyD'])) player.vx *= friction;
		player.vx = Math.max(-maxSpeed, Math.min(maxSpeed, player.vx));

		// Jump: keyboard or gamepad button 0 (A / Cross)
		let jumpPressed = keys['ArrowUp']||keys['KeyW']||keys['Space'];
		if (gpConnected){
			const gp = navigator.getGamepads()[gpIndex];
			if (gp){
				jumpPressed = jumpPressed || !!gp.buttons[0].pressed;
			}
		}
		if (jumpPressed && player.onGround){ player.vy = -12; player.onGround = false; }

		// Gravity
		player.vy += gravity;

		// Apply velocity
		player.x += player.vx;
		player.y += player.vy;

		// Collision with platforms (AABB, simple resolution)
		player.onGround = false;
		for (const p of platforms){
			if (rectsOverlap(player,p)){
				// Determine overlap directions
				const pxCenter = p.x + p.w/2, pyCenter = p.y + p.h/2;
				const dx = (player.x + player.w/2) - pxCenter;
				const dy = (player.y + player.h/2) - pyCenter;
				const px = (p.w + player.w)/2, py = (p.h + player.h)/2;
				const wy = px * dy, hx = py * dx;
				if (wy > hx){
					if (wy > -hx){
						// top
						player.y = p.y - player.h; player.vy = 0; player.onGround = true;
					} else {
						// left
						player.x = p.x - player.w; player.vx = 0;
					}
				} else {
					if (wy > -hx){
						// right
						player.x = p.x + p.w; player.vx = 0;
					} else {
						// bottom
						player.y = p.y + p.h; player.vy = 0;
					}
				}
			}
		}

		// Boundaries
			if (player.x < 0) { player.x = 0; player.vx = 0; }
			if (player.x + player.w > world.width) { player.x = world.width - player.w; player.vx = 0; }
		if (player.y > H) { // fell off
			// reset to start
				loseLife();
		}

			// Check flag
			if (rectsOverlap(player, flag)){
				nextLevel();
			}

			// Collectibles
			for (const c of collectibles){
				if (!c.collected && rectsOverlap(player,c)){
					c.collected = true; score += 100; spawnParticles(c.x+6,c.y+6,'gold');
				}
			}

			// Enemies (patrol)
			for (const e of enemies){
				e.x += e.spd * e.dir;
				if (e.x < e.range[0]) e.dir = 1;
				if (e.x > e.range[1]) e.dir = -1;
				if (rectsOverlap(player,e)){
					hitEnemy(e);
				}
			}

		return true;
	}

	function draw(){
			// Smooth camera follow (lerp) with lookahead
			const lookaheadX = Math.max(-120, Math.min(120, player.vx * 12));
			const lookaheadY = Math.max(-40, Math.min(40, player.vy * 4));
			const targetX = player.x + player.w/2 - camera.w/2 + lookaheadX;
			const targetY = player.y + player.h/2 - camera.h/2 + lookaheadY;
			const lerp = 0.1;
			camera.sx += (targetX - camera.sx) * lerp;
			camera.sy += (targetY - camera.sy) * lerp;
			// Clamp to world bounds
			camera.sx = Math.max(0, Math.min(world.width - camera.w, camera.sx));
			camera.sy = Math.max(0, Math.min(world.height - camera.h, camera.sy));

			// Clear
			ctx.clearRect(0,0,W,H);

			// Parallax background (simple repeated layers)
			// far layer
			const farSpeed = 0.2; const nearSpeed = 0.5;
			ctx.fillStyle = '#071225'; ctx.fillRect(0,0,W,H);
			// far stars
			ctx.fillStyle = '#0a3';
			for (let i=0;i<40;i++){
				const sx = ((i*73) - camera.sx*farSpeed) % (world.width);
				const sy = 30 + (i*17 % (world.height/2)) - camera.sy*farSpeed*0.2;
				const px = ((sx + world.width) % world.width) * (W/world.width);
				const py = (sy % world.height) * (H/world.height);
				ctx.fillRect(px, py, 2,2);
			}
			// near hills
			ctx.fillStyle = '#0f1b2a';
			const hillOffset = -camera.sx * nearSpeed;
			ctx.beginPath();
			ctx.moveTo(0,H);
			for (let x=0;x<=W;x+=40){
				const worldX = camera.sx + x*(world.width/W) + hillOffset;
				const y = H - 60 - 20*Math.sin(worldX*0.01);
				ctx.lineTo(x, y);
			}
			ctx.lineTo(W,H); ctx.fill();

			// Platforms (translate world -> camera)
			ctx.save();
			ctx.translate(-camera.sx, -camera.sy);
			for (const p of platforms){
				ctx.fillStyle = '#555'; ctx.fillRect(p.x, p.y, p.w, p.h);
				ctx.strokeStyle = '#222'; ctx.strokeRect(p.x, p.y, p.w, p.h);
			}

			// Collectibles
			for (const c of collectibles){
				if (c.collected) continue;
				ctx.fillStyle = '#f4d35e'; ctx.fillRect(c.x, c.y, c.w, c.h);
				ctx.strokeStyle = '#9b6f12'; ctx.strokeRect(c.x, c.y, c.w, c.h);
			}

			// Enemies
			for (const e of enemies){
				ctx.fillStyle = '#ff6b6b'; ctx.fillRect(e.x, e.y, e.w, e.h);
				ctx.fillStyle = '#000'; ctx.fillRect(e.x+6, e.y+8, 4,4);
			}

			// Flag
			ctx.fillStyle = '#2ecc71'; ctx.fillRect(flag.x, flag.y, flag.w, flag.h);
			ctx.fillStyle = '#111'; ctx.fillRect(flag.x+6, flag.y+8, 4, flag.h-16);

			// Player
			ctx.fillStyle = '#ffd166'; ctx.fillRect(player.x, player.y, player.w, player.h);
			// eyes
			ctx.fillStyle = '#000'; ctx.fillRect(player.x + 6, player.y + 10, 4,4);
			ctx.fillRect(player.x + player.w - 10, player.y + 10, 4,4);
			ctx.restore();

			// Particles (screen space, but spawned in world coords converted here)
			for (let i = particles.length-1;i>=0;i--){
				const p = particles[i];
				p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life -= 1;
				ctx.fillStyle = p.color; ctx.fillRect(p.x - camera.sx, p.y - camera.sy, p.size, p.size);
				if (p.life <= 0) particles.splice(i,1);
			}

			// HUD (screen-space)
			ctx.fillStyle = '#ddd'; ctx.font = '14px system-ui'; ctx.textAlign='left';
			ctx.fillText('Position: ' + Math.round(player.x) + ',' + Math.round(player.y), 8, 20);
			ctx.fillText('Camera: ' + Math.round(camera.sx) + ',' + Math.round(camera.sy), 8, 40);
			ctx.fillText('Gamepad: ' + (gpConnected ? 'connected' : 'none'), 8, 60);
			ctx.fillText('Score: ' + score, W - 140, 20);
			ctx.fillText('Lives: ' + lives, W - 140, 40);
			ctx.fillText('Level: ' + (currentLevel+1) + '/' + levels.length, W - 140, 60);
	}

	let last = 0;
	function loop(ts){
		if (!ts) ts = performance.now();
		const dt = Math.min(32, ts - last); last = ts;
		const keepGoing = physics(dt);
		draw();
		if (keepGoing) requestAnimationFrame(loop);
	}

	// Start
	init();

	// UI buttons
	document.getElementById('prevLevel').addEventListener('click', ()=>{ currentLevel = Math.max(0,currentLevel-1); loadLevel(currentLevel); });
	document.getElementById('nextLevel').addEventListener('click', ()=>{ currentLevel = Math.min(levels.length-1,currentLevel+1); loadLevel(currentLevel); });

	function nextLevel(){
		currentLevel = Math.min(levels.length-1, currentLevel+1);
		if (currentLevel < levels.length) loadLevel(currentLevel);
	}

	function loseLife(){
		lives -= 1;
		if (lives <= 0){
			// game over
			ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H); ctx.fillStyle = '#fff'; ctx.font='36px sans-serif'; ctx.textAlign='center';
			ctx.fillText('Game Over', W/2,H/2);
			// reset game
			setTimeout(()=>{ lives = 3; score = 0; currentLevel = 0; loadLevel(currentLevel); }, 1200);
		} else {
			// respawn
			player.x = 50; player.y = 300; player.vx = player.vy = 0;
		}
	}

	function hitEnemy(e){
		// simple knockback and life loss
		spawnParticles(player.x+player.w/2, player.y+player.h/2, 'red');
		loseLife();
	}

	function spawnParticles(x,y,color){
		for (let i=0;i<12;i++){
			particles.push({x:x,y:y,vx:(Math.random()-0.5)*4,vy:(Math.random()-1.5)*4,life:30,size:2+Math.random()*3,color: color==='gold' ? '#f4d35e' : '#ff6b6b'});
		}
	}
	</script>
</body>
</html>
